

#include "../includes/push_swap.h"

void    _init_var(t_wheel *wheel)
{
    wheel->top_a = 0;
    wheel->top_b = 0;
    wheel->preaxe = 0;
}

static void    print_instr(int instr, int pres)
{
    if (pres == 0)
        ft_putstr_fd("sa\n", 1);
    if (pres == 1)
        ft_putstr_fd("sa\n", 1);
    if (pres == 2)
        ft_putstr_fd("pa\n", 1);
    if (pres == 3)
        ft_putstr_fd("pb\n", 1);
    if (pres == 4)
        ft_putstr_fd("ra\n", 1);
    if (pres == 5)
        ft_putstr_fd("rb\n", 1);
    if (pres == 6)
        ft_putstr_fd("rra\n", 1);
    if (pres == 7)
        ft_putstr_fd("rrb\n", 1);
    if (pres == 8)
        ft_putstr_fd("ss\n", 1);
    if (pres == 9)
        ft_putstr_fd("rr\n", 1);
    if (pres == 10)
        ft_putstr_fd("rrr\n", 1);
}

static int      _top(t_stack **stack, int data)
{
    int         i;
    int         l;
    int         ninstr;
    t_stack     *tmp;

    ninstr = 0;
    if (!stack || !*stack)
        return (0);
    l = lstsize2(*stack);
    i = lst_order(*stack, data);
    tmp = lstcpy(*stack);
    while (tmp->data != data)
    {
        if (i <= l / 2)
            r(&tmp);
        else
            rr(&tmp);
        ninstr++;
    }
    free_list(tmp);
    tmp = NULL;
    return (ninstr);
}

static void      _toping(t_stack **stack, t_stack **extra, int data, int s)
{
    int         i;
    int         l;
    t_stack     *tmp;

    if (!stack || !*stack)
        return ;
    tmp = *stack;
    l = lstsize2(*stack);
    i = lst_order(*stack, data);
    while ((*stack)->data != data)
    {
        if (i <= l / 2)
        {
            if (s == 1)
                print_instr(r(stack), 4);
            if (s == 2)
                print_instr(r(stack), 5);
            if (s == 3)
                print_instr(both(stack, extra, 2), 9);
        }
        else
        {
            if (s == 1)
                print_instr(rr(stack), 6);
            if (s == 2)
                print_instr(rr(stack), 7);
            if (s == 3)
                print_instr(both(stack, extra, 3), 10);
        }
    }
}

int     find_preaxe(t_stack *stack, int axe)
{
    size_t      l;
    int         i;
    int         *data;

    i = -1;
    if (!stack)
        return (0);
    push(&stack, axe);
    l = quicksort(stack, &data);
    while (++i < l && data[i] != axe)
        ;
    if (i == 0)
        return (data[l - 1]);
    return (data[i - 1]);
}

static int      s_scan(t_stack *a, t_stack *b, t_wheel *wheel)
{
    t_stack     *tmp;
    int         i;
    int         l_a;
    int         l_b;
    int         index[lstsize2(a)];

    l_a = lstsize2(a);
    l_b = lstsize2(b);
    tmp = a;
    i = -1;
    while (++i < l_a)
    {
        wheel->preaxe = find_preaxe(b, tmp->data);
        wheel->top_a = _top(&a, tmp->data);
        wheel->top_b = _top(&b, wheel->preaxe);
        wheel->similarity = 0;
        // printf("\n###\tvar %15s: %i\t###\n", "tmp->data:", tmp->data);
        // printf("###\tvar %15s: %i\t###\n", "preaxe:", wheel.preaxe);
        // printf("###\tvar %15s: %i\t###\n", "top_a", wheel.top_a);
        // printf("###\tvar %15s: %i\t###\n", "top_b", wheel.top_b);
        if ((lst_order(a, tmp->data) <= l_a / 2 && lst_order(b, wheel->preaxe) <= l_b / 2) ||
            (lst_order(a, tmp->data) > l_a / 2 && lst_order(b, wheel->preaxe) > l_b / 2))
        {
            if (wheel->top_a > wheel->top_b)
            {
                index[i] = wheel->top_a;
                wheel->similarity = wheel->top_b;
            }
            else
            {
                index[i] = wheel->top_b;
                wheel->similarity = wheel->top_a;
            }
        }
        else
            index[i] = wheel->top_a + wheel->top_b;
        tmp = tmp->next;
    }
    i = 0;
    wheel->smaller = index[i];
    wheel->top = 0;
    while (++i < l_a)
    {
        if (index[i] == wheel->smaller)
            if (lst_elem(a, i) < lst_elem(a, wheel->top))
                wheel->top = i;
        if (index[i] < wheel->smaller)
        {
            wheel->smaller = index[i];
            wheel->top = i;
        }
    }
    // printf("###\tvar %15s: %i\t###\n", "to be topped", lst_elem(a, wheel.top)));
    return (lst_elem(a, wheel->top));
}

void    sort(t_stack **a, t_stack **b)
{
    t_wheel wheel;
    int     top;
    int     *data;
    int     l;

    _init_var(&wheel);
    while (PHASE_1)
    {
        if ((*a)->data > (*a)->next->data)
            print_instr(s(a), 1);
        if (is_sorted(*a, *b, 1))
            break;
        top = s_scan(*a, *b, &wheel);
        // printf("###\tvar %15s: %i\t###\n", "similarity:", wheel.similarity);
        // while (--(wheel.similarity) > -1)
        //     _toping(a, b, top, 3);
        _toping(a, b, top, 1);;
        // print_list(*a, *b);
        _toping(b, a, top, 2);
        // print_list(*a, *b);
        print_instr(p(a, b), 3);
    }
    l = quicksort(*b, &data);
    while (PHASE_2)
    {
        _toping(b, a, data[l - 1], 2);
        // print_list(*a, *b);
        l--;
        print_instr(p(b, a), 2);
    }
}



        printf("###\tvar %15s: %i\t###\n", "smaller:", smaller);
        printf("###\tvar %15s: %i\t###\n", "i:", i);
        printf("###\tvar %15s: %i\t###\n", "topper:", lst_elem(a, top));
        printf("###\tvar %15s: %i\t###\n", "lst_elem(a, i)", lst_elem(a, i));
        printf("###\tvar %15s: %i\t###\n", "index", index[i]);


        static int      _top(t_stack **stack, int data, int code) // fully functional
{
    int         i;
    int         l;
    int         ninstr;
    t_stack     *tmp;

    i = 0;
    ninstr = 0;
    if (!stack || !*stack)
        return (0);
    tmp = *stack;
    l = lstsize2(*stack);
    while (tmp->data != data && ++i <= l)
        tmp = tmp->next;
    if (code == 0)
        tmp = lstcpy(*stack);
    else if (code == 1)
        tmp = *stack;
    while (tmp->data != data)
    {
        if (i > l / 2)
            rr(&tmp);
        else
            r(&tmp);
        ninstr++;
    }
    if (code == 0)
    {
        free_list(tmp);
        tmp = NULL;
        action -= ninstr;
    }
    return (ninstr);
}

  if (data == 10 && code == 1)
    {
        puts("\n\nHERE WE ARE ============================================\n\n");
        print_list(*stack, NULL);
        printf("###\tvar %15s: %i\t###\n", "l", l);
        printf("###\tvar %15s: %i\t###\n", "l / 2", l / 2);
        printf("###\tvar %15s: %i\t###\n", "i", i);
        printf("###\tvar %15s: %i\t###\n", "tmp->data", tmp->data);
        print_list(tmp, NULL);
    }